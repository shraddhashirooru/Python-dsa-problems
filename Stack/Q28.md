# Question 28: Sum of subarray ranges:

## You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray. Return the sum of all subarray ranges of nums. A subarray is a contiguous non-empty sequence of elements within an array.

---
### Example 1:

Input: nums = [1,2,3]

Output: 4

Explanation: The 6 subarrays of nums are the following:

[1], range = largest - smallest = 1 - 1 = 0 

[2], range = 2 - 2 = 0

[3], range = 3 - 3 = 0

[1,2], range = 2 - 1 = 1

[2,3], range = 3 - 2 = 1

[1,2,3], range = 3 - 1 = 2

So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.

---
## ✅Python code:

```
class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
       
        def Nse(nums):
            stack=[]
            n=len(nums)
            a=[0]*n
            for i in range(n-1,-1,-1):
                while stack and nums[stack[-1]]>=nums[i]:
                    stack.pop()
                if stack:
                    a[i]=stack[-1]
                else:
                    a[i]=n
                stack.append(i)
            return a
        def Pse(nums):
            stack=[]
            n=len(nums)
            b=[0]*n
            for i in range(n):
                while stack and nums[stack[-1]]>nums[i]:
                    stack.pop()
                if stack:
                    b[i]=stack[-1]
                else:
                    b[i]=-1
                stack.append(i)
            return b

        def Nge(nums):
            stack=[]
            n=len(nums)
            c=[0]*n
            for i in range(n-1,-1,-1):
                while stack and nums[stack[-1]]<=nums[i]:
                    stack.pop()
                if stack:
                    c[i]=stack[-1]
                else:
                    c[i]=n
                stack.append(i)
            return c
        def Pge(nums):
            stack=[]
            n=len(nums)
            d=[0]*n
            for i in range(n):
                while stack and nums[stack[-1]]<nums[i]:
                    stack.pop()
                if stack:
                    d[i]=stack[-1]
                else:
                    d[i]=-1
                stack.append(i)
            return d
        def Summin(nums):
            n=len(nums)
            count=0
            x=Nse(nums)
            y=Pse(nums)
            for i in range(n):
                left=x[i]-i
                right=i-y[i]
                count=count+left*right*nums[i]
            return count
        def Summax(nums):
            n=len(nums)
            count=0
            x=Nge(nums)
            y=Pge(nums)
            for i in range(n):
                left=x[i]-i
                right=i-y[i]
                count=count+left*right*nums[i]
            return count
        return Summax(nums)-Summin(nums)
 ```

---
## ✅Python code 2:

```
class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        def Summin(nums):
            stack=[]
            n=len(nums)
            d=[0]*n
            for i in range(n):
                while stack and nums[stack[-1]]>=nums[i]:
                    a=stack.pop()
                    if stack:
                        d[a]=(i-a)*(a-stack[-1])*nums[a]
                    else:
                        d[a]=(i-a)*(a-(-1))*nums[a]
                stack.append(i)
            while stack:
                a=stack.pop()
                if stack:
                    d[a]=(n-a)*(a-stack[-1])*nums[a]
                else:
                    d[a]=(n-a)*(a-(-1))*nums[a]
            return d
        def Summax(nums):
            stack=[]
            n=len(nums)
            d=[0]*n
            for i in range(n):
                while stack and nums[stack[-1]]<=nums[i]:
                    a=stack.pop()
                    if stack:
                        d[a]=(i-a)*(a-stack[-1])*nums[a]
                    else:
                        d[a]=(i-a)*(a-(-1))*nums[a]
                stack.append(i)
            while stack:
                a=stack.pop()
                if stack:
                    d[a]=(n-a)*(a-stack[-1])*nums[a]
                else:
                    d[a]=(n-a)*(a-(-1))*nums[a]
            return d
        x=Summax(nums)
        y=Summin(nums)
        count=0
        n=len(nums)
        for i in range(n):
            count=count+(x[i]-y[i])
        return count
```

---
## ✅Python code 3:

```
class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        def Summin(nums):
            stack=[]
            n=len(nums)
            total=0
            for i in range(n):
                while stack and nums[stack[-1]]>=nums[i]:
                    a=stack.pop()
                    if stack:
                        total=total+(i-a)*(a-stack[-1])*nums[a]
                    else:
                        total=total+(i-a)*(a-(-1))*nums[a]
                stack.append(i)
            while stack:
                a=stack.pop()
                if stack:
                    total=total+(n-a)*(a-stack[-1])*nums[a]
                else:
                    total=total+(n-a)*(a-(-1))*nums[a]
            return total
        def Summax(nums):
            stack=[]
            n=len(nums)
            total=0
            for i in range(n):
                while stack and nums[stack[-1]]<=nums[i]:
                    a=stack.pop()
                    if stack:
                        total=total+(i-a)*(a-stack[-1])*nums[a]
                    else:
                        total=total+(i-a)*(a-(-1))*nums[a]
                stack.append(i)
            while stack:
                a=stack.pop()
                if stack:
                    total=total+(n-a)*(a-stack[-1])*nums[a]
                else:
                    total=total+(n-a)*(a-(-1))*nums[a]
            return total
        return Summax(nums)-Summin(nums)
```
